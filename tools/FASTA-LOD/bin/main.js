// Generated by Haxe 4.0.0-preview.5+7eb789f54
(function () { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}var js_node_ChildProcess = require("child_process");
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var Sys = function() { };
Sys.__name__ = true;
Sys.environment = function() {
	var m = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(process.env);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		var v = process.env[key];
		if(__map_reserved[key] != null) {
			m.setReserved(key,v);
		} else {
			m.h[key] = v;
		}
	}
	return m;
};
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		var other = _g;
		return other;
	}
};
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw new js__$Boot_HaxeError("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b1 = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b1) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b1;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
};
var Console = function() { };
Console.__name__ = true;
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	s += "<//>";
	var activeFormatFlagStack = new haxe_ds_List();
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var str = e.matched(2);
		str = str.toLowerCase();
		var flag;
		if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
			var hIdx = str.indexOf("#");
			var hex = HxOverrides.substr(str,hIdx + 1,null);
			if(hex.length == 3) {
				var a = hex.split("");
				hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
			}
			if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
				flag = "";
			} else {
				var normalized = str.substring(0,hIdx) + "#" + hex;
				flag = normalized;
			}
		} else {
			switch(str) {
			case "!":
				flag = "invert";
				break;
			case "/":
				flag = "reset";
				break;
			case "b":
				flag = "bold";
				break;
			case "bg_gray":
				flag = "bg_light_black";
				break;
			case "gray":
				flag = "light_black";
				break;
			case "i":
				flag = "italic";
				break;
			case "u":
				flag = "underline";
				break;
			default:
				var transformed = str;
				flag = transformed;
			}
		}
		var open = e.matched(1) == null;
		if(flag == "reset") {
			activeFormatFlagStack.clear();
		} else if(open) {
			activeFormatFlagStack.add(flag);
		} else if(flag != "") {
			activeFormatFlagStack.remove(flag);
		} else {
			var result1 = activeFormatFlagStack.last();
			activeFormatFlagStack.remove(result1);
		}
		switch(Console.formatMode) {
		case 0:
			if(open) {
				var last = Console.getAsciiFormat(activeFormatFlagStack.last());
				if(last != null) {
					return last;
				} else {
					return "";
				}
			} else {
				return Console.getAsciiFormat("reset") + activeFormatFlagStack.map(function(f) {
					return Console.getAsciiFormat(f);
				}).filter(function(s1) {
					return s1 != null;
				}).join("");
			}
			break;
		case 1:
			var result2 = activeFormatFlagStack.map(function(f1) {
				return Console.getBrowserFormat(f1);
			}).filter(function(s2) {
				return s2 != null;
			}).join(";");
			browserFormatArguments.push(result2);
			return "%c";
		case 2:
			return "";
		}
	});
	if(Console.formatMode == 1) {
		var logArgs = [result].concat(browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(Console.unicodeCompatibilityMode == 1 && !Console.unicodeCompatibilityEnabled) {
		Console.exec("chcp 65001");
		Console.unicodeCompatibilityEnabled = true;
	}
	switch(outputStream) {
	case 1:case 2:
		new _$Sys_FileOutput(2).writeString(s);
		break;
	case 0:case 3:
		new _$Sys_FileOutput(1).writeString(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[38;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex1 = HxOverrides.substr(flag,3,null);
		var r1 = Std.parseInt("0x" + HxOverrides.substr(hex1,0,2));
		var g1 = Std.parseInt("0x" + HxOverrides.substr(hex1,2,2));
		var b1 = Std.parseInt("0x" + HxOverrides.substr(hex1,4,2));
		return "\x1B[48;5;" + Console.rgbToAscii256(r1,g1,b1) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return null;
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g = 0;
		var _g1 = set.length;
		while(_g < _g1) {
			var i = _g++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var ier = Math.abs(r - colorSteps[ir]);
	var ieg = Math.abs(g - colorSteps[ig]);
	var ieb = Math.abs(b - colorSteps[ib]);
	var averageColorError = ier + ieg + ieb;
	var jr = Math.round((r - 8) / 10);
	var jg = Math.round((g - 8) / 10);
	var jb = Math.round((b - 8) / 10);
	var jer = Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8));
	var jeg = Math.abs(g - Math.max(Math.min(jg * 10 + 8,238),8));
	var jeb = Math.abs(b - Math.max(Math.min(jb * 10 + 8,238),8));
	var averageGrayError = jer + jeg + jeb;
	if(averageGrayError < averageColorError && r == g && g == b) {
		var grayIndex = jr + 232;
		return grayIndex;
	} else {
		var colorIndex = 16 + ir * 36 + ig * 6 + ib;
		return colorIndex;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return null;
	}
};
Console.determineConsoleFormatMode = function() {
	if(typeof(window) != "undefined") {
		return 1;
	}
	var tputColors = Console.exec("tput colors");
	if(tputColors.exit == 0 && Std.parseInt(tputColors.stdout) > 2) {
		return 0;
	}
	var _this = Sys.environment();
	var termEnv = __map_reserved["TERM"] != null ? _this.getReserved("TERM") : _this.h["TERM"];
	if(termEnv != null && new EReg("cygwin|xterm|vt100","").match(termEnv)) {
		return 0;
	}
	return 2;
};
Console.exec = function(cmd,args) {
	var p = js_node_ChildProcess.spawnSync(cmd,args,{ });
	var stdout = p.stdout == null ? "" : p.stdout.toString();
	if(stdout == null) {
		stdout = "";
	}
	return { exit : p.status, stdout : stdout};
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Main = function() { };
Main.__name__ = true;
Main.convertFastaSequenceName = function(name) {
	if(Main.sequenceNameFilter != null) {
		Main.sequenceNameFilter.match(name);
		return "chr" + Main.sequenceNameFilter.matched(1) + ".bin";
	} else {
		return "" + name + ".bin";
	}
};
Main.main = function() {
	var args = process.argv.slice(2);
	if(args.length < 1) {
		Console.printFormatted(Console.errorPrefix + "Pass a fasta path and optional chromosome number as arguments" + "\n",2);
		process.exit(1);
		return;
	}
	var fastaFilePath = args[0];
	var fastaFilename = haxe_io_Path.withoutExtension(haxe_io_Path.withoutDirectory(fastaFilePath));
	var chromosomeFilter = args[1] != null ? args[1] : "\\w+";
	var filter = "^(" + chromosomeFilter + ") dna:chromosome chromosome";
	Console.printFormatted(Console.logPrefix + ("" + ("Filter is \"" + filter + "\"")) + "\n",0);
	Main.sequenceNameFilter = new EReg(filter,"");
	var generatedFilePaths = Main.convertFastaFile(fastaFilePath,haxe_io_Path.join(["_output",fastaFilename]));
	var _g = 0;
	while(_g < generatedFilePaths.length) {
		var path = generatedFilePaths[_g];
		++_g;
		sys_FileSystem.createDirectory(haxe_io_Path.withoutExtension(path));
		Main.convertToUByte(path,haxe_io_Path.withoutExtension(path) + "/0.bin");
		var inputPath = path;
		var level = 1;
		var lastDoubleLodPath = null;
		while(true) {
			var outputPath = haxe_io_Path.withoutExtension(path) + ("-lod" + level + ".double");
			if(!Main.downsample(inputPath,outputPath)) {
				break;
			}
			Main.convertToUByte(outputPath,haxe_io_Path.withoutExtension(path) + ("/" + level + ".bin"));
			if(lastDoubleLodPath != null) {
				js_node_Fs.unlinkSync(lastDoubleLodPath);
			}
			lastDoubleLodPath = outputPath;
			inputPath = outputPath;
			++level;
		}
		if(lastDoubleLodPath != null) {
			js_node_Fs.unlinkSync(lastDoubleLodPath);
		}
	}
	var _g1 = 0;
	while(_g1 < generatedFilePaths.length) {
		var path1 = generatedFilePaths[_g1];
		++_g1;
		js_node_Fs.unlinkSync(path1);
	}
};
Main.convertToUByte = function(path,outputPath,chunkSize_blocks) {
	if(chunkSize_blocks == null) {
		chunkSize_blocks = 20000000;
	}
	Console.printFormatted(Console.logPrefix + ("" + ("<cyan>Converting to byte format \"<b>" + path + "</b>\"</cyan>")) + "\n",0);
	var range = Main.minMax(path);
	var delta = range.max - range.min;
	js_node_Fs.writeFileSync(outputPath + ".minmax",JSON.stringify(range));
	var acgtBlockSize = 32;
	var chunkSize_bytes = chunkSize_blocks * acgtBlockSize;
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var chunksRequired = Math.ceil(_$UInt_UInt_$Impl_$.toFloat(length_bytes) / _$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes));
	var output = new sys_io_FileOutput(js_node_Fs.openSync(outputPath,"w"));
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var t0 = new Date().getTime() / 1000;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(_$UInt_UInt_$Impl_$.toFloat(bytesRemaining),_$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes)) | 0;
		var inputBytes = input.read(bytesToRead);
		var chunk_blocks = inputBytes.length / acgtBlockSize | 0;
		var outputBytes = new haxe_io_Bytes(new ArrayBuffer(chunk_blocks * 4));
		var _g2 = 0;
		var _g11 = chunk_blocks;
		while(_g2 < _g11) {
			var i = _g2++;
			var ip = i * acgtBlockSize;
			var a = inputBytes.getDouble(ip);
			var c = inputBytes.getDouble(ip + 8);
			var g = inputBytes.getDouble(ip + 16);
			var t = inputBytes.getDouble(ip + 24);
			var scaleFactor = delta == 0 ? 0 : 1 / delta;
			var op = i * 4;
			outputBytes.b[op] = Math.round(Math.min((a - range.min) * scaleFactor,1.) * 255);
			outputBytes.b[op + 1] = Math.round(Math.min((c - range.min) * scaleFactor,1.) * 255);
			outputBytes.b[op + 2] = Math.round(Math.min((g - range.min) * scaleFactor,1.) * 255);
			outputBytes.b[op + 3] = Math.round(Math.min((t - range.min) * scaleFactor,1.) * 255);
		}
		output.write(outputBytes);
		var dt = new Date().getTime() / 1000 - t0;
		var progress = (chunk + 1) / chunksRequired;
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)")) + "\n",0);
	}
	input.close();
	output.close();
	Console.printFormatted(Console.successPrefix + ("" + ("<light_green>Saved \"<b>" + outputPath + "</b>\"<//>")) + "\n",0);
};
Main.minMax = function(path,chunkSize_blocks) {
	if(chunkSize_blocks == null) {
		chunkSize_blocks = 20000000;
	}
	Console.printFormatted(Console.logPrefix + ("" + ("<cyan>Computing min/max of \"<b>" + path + "</b>\"</cyan>")) + "\n",0);
	var acgtBlockSize = 32;
	var chunkSize_bytes = chunkSize_blocks * acgtBlockSize;
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var chunksRequired = Math.ceil(_$UInt_UInt_$Impl_$.toFloat(length_bytes) / _$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes));
	var max = -Infinity;
	var min = Infinity;
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var t0 = new Date().getTime() / 1000;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(_$UInt_UInt_$Impl_$.toFloat(bytesRemaining),_$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes)) | 0;
		var inputBytes = input.read(bytesToRead);
		var chunk_blocks = inputBytes.length / acgtBlockSize | 0;
		var _g2 = 0;
		var _g11 = chunk_blocks;
		while(_g2 < _g11) {
			var i = _g2++;
			var ip = i * acgtBlockSize;
			var a = inputBytes.getDouble(ip);
			var c = inputBytes.getDouble(ip + 8);
			var g = inputBytes.getDouble(ip + 16);
			var t = inputBytes.getDouble(ip + 24);
			var localMax = Math.max(Math.max(a,c),Math.max(g,t));
			var localMin = Math.min(Math.min(a,c),Math.min(g,t));
			max = Math.max(localMax,max);
			min = Math.min(localMin,min);
		}
		var dt = new Date().getTime() / 1000 - t0;
		var progress = (chunk + 1) / chunksRequired;
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)")) + "\n",0);
	}
	input.close();
	Console.printFormatted(Console.successPrefix + ("" + ("min: " + min + ", max: " + max)) + "\n",0);
	return { min : min, max : max};
};
Main.downsample = function(path,outputPath,chunkSize_blocks) {
	if(chunkSize_blocks == null) {
		chunkSize_blocks = 20000000;
	}
	if((_$UInt_UInt_$Impl_$.toFloat(chunkSize_blocks) % _$UInt_UInt_$Impl_$.toFloat(2) | 0) != 0) {
		throw new js__$Boot_HaxeError("chunkSize_blocks must be multiple of 2");
	}
	var acgtBlockSize = 32;
	var chunkSize_bytes = chunkSize_blocks * acgtBlockSize;
	Console.printFormatted(Console.logPrefix + ("" + ("<cyan>Downsampling \"<b>" + path + "</b>\"</cyan>")) + "\n",0);
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var length_blocks = length_bytes / acgtBlockSize | 0;
	var chunksRequired = Math.ceil(_$UInt_UInt_$Impl_$.toFloat(length_bytes) / _$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes));
	if(_$UInt_UInt_$Impl_$.gte(1,length_blocks)) {
		input.close();
		return false;
	}
	var output_blocks = Math.ceil(_$UInt_UInt_$Impl_$.toFloat(length_blocks) / _$UInt_UInt_$Impl_$.toFloat(2));
	var output_bytes = output_blocks * acgtBlockSize;
	Console.printFormatted(Console.logPrefix + ("" + ("\tacgtBlockSize: " + acgtBlockSize)) + "\n",0);
	Console.printFormatted(Console.logPrefix + ("" + ("\tchunkSize_bytes: " + Std.string(_$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes)))) + "\n",0);
	Console.printFormatted(Console.logPrefix + ("" + ("\tchunksRequired: " + chunksRequired)) + "\n",0);
	Console.printFormatted(Console.logPrefix + ("" + ("\tlength_bytes: " + length_bytes)) + "\n",0);
	Console.printFormatted(Console.logPrefix + ("" + ("\tlength_blocks: " + Std.string(_$UInt_UInt_$Impl_$.toFloat(length_blocks)))) + "\n",0);
	Console.printFormatted(Console.logPrefix + ("" + ("\toutput_blocks: " + Std.string(_$UInt_UInt_$Impl_$.toFloat(output_blocks)))) + "\n",0);
	Console.printFormatted(Console.logPrefix + ("" + ("\toutput_bytes: " + Std.string(_$UInt_UInt_$Impl_$.toFloat(output_bytes)))) + "\n",0);
	var output = new sys_io_FileOutput(js_node_Fs.openSync(outputPath,"w"));
	Console.printFormatted(Console.logPrefix + ("" + ("Created \"<b>" + outputPath + "</b>\"")) + "\n",0);
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var t0 = new Date().getTime() / 1000;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(_$UInt_UInt_$Impl_$.toFloat(bytesRemaining),_$UInt_UInt_$Impl_$.toFloat(chunkSize_bytes)) | 0;
		var inputBytes = input.read(bytesToRead);
		var chunk_blocks = inputBytes.length / acgtBlockSize | 0;
		var downsample_blocks = Math.ceil(_$UInt_UInt_$Impl_$.toFloat(chunk_blocks) / _$UInt_UInt_$Impl_$.toFloat(2));
		var downsampleBytes = new haxe_io_Bytes(new ArrayBuffer(downsample_blocks * acgtBlockSize));
		var _g2 = 0;
		var _g11 = downsample_blocks;
		while(_g2 < _g11) {
			var block = _g2++;
			var leftBlock = block * 2;
			var rightBlock = leftBlock + 1;
			if(_$UInt_UInt_$Impl_$.gt(rightBlock,chunk_blocks - 1)) {
				rightBlock = chunk_blocks - 1;
				if(chunk != chunksRequired - 1) {
					Console.printFormatted(Console.errorPrefix + "Right sample overflowed chunk unexpectedly" + "\n",2);
				}
			}
			var ipl = leftBlock * acgtBlockSize;
			var ipr = rightBlock * acgtBlockSize;
			var al = inputBytes.getDouble(ipl + 0);
			var cl = inputBytes.getDouble(ipl + 8);
			var gl = inputBytes.getDouble(ipl + 16);
			var tl = inputBytes.getDouble(ipl + 24);
			var ar = inputBytes.getDouble(ipr + 0);
			var cr = inputBytes.getDouble(ipr + 8);
			var gr = inputBytes.getDouble(ipr + 16);
			var tr = inputBytes.getDouble(ipr + 24);
			var op = block * acgtBlockSize;
			downsampleBytes.setDouble(op,(al + ar) * 0.5);
			downsampleBytes.setDouble(op + 8,(cl + cr) * 0.5);
			downsampleBytes.setDouble(op + 16,(gl + gr) * 0.5);
			downsampleBytes.setDouble(op + 24,(tl + tr) * 0.5);
		}
		output.write(downsampleBytes);
		var dt = new Date().getTime() / 1000 - t0;
		var progress = (chunk + 1) / chunksRequired;
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)")) + "\n",0);
	}
	input.close();
	output.close();
	return true;
};
Main.convertFastaFile = function(path,outputDirectory,chunkSize_bytes) {
	if(chunkSize_bytes == null) {
		chunkSize_bytes = 10000000;
	}
	Console.printFormatted(Console.logPrefix + ("" + ("<cyan>Reading \"<b>" + path + "</b>\"</cyan>")) + "\n",0);
	var currentOutputBuffer;
	var generatedFilePaths = [];
	var skipSequence = false;
	var returnSequence = true;
	var onFastaSequenceStart = function(name) {
		skipSequence = false;
		returnSequence = true;
		if(Main.sequenceNameFilter != null) {
			if(!Main.sequenceNameFilter.match(name)) {
				Console.printFormatted(Console.warnPrefix + ("" + ("Skipping \"<b>" + name + "</b>\" because it was not included in filter")) + "\n",1);
				skipSequence = true;
				returnSequence = false;
				return;
			}
		}
		Console.printFormatted(Console.logPrefix + ("" + ("Started sequence \"<b>" + name + "</b>\"")) + "\n",0);
		var filename = Main.convertFastaSequenceName(name);
		sys_FileSystem.createDirectory(outputDirectory);
		var path1 = haxe_io_Path.join([outputDirectory,filename]);
		if(returnSequence) {
			generatedFilePaths.push(path1);
		}
		if(sys_FileSystem.exists(path1)) {
			Console.printFormatted(Console.warnPrefix + ("" + ("Skipping \"<b>" + path1 + "</b>\" because file already exists")) + "\n",1);
			skipSequence = true;
			return;
		}
		if(currentOutputBuffer != null) {
			currentOutputBuffer.close();
		}
		currentOutputBuffer = new sys_io_FileOutput(js_node_Fs.openSync(path1,"w"));
	};
	var onFastaSequenceChunk = function(sequenceChunk) {
		if(skipSequence) {
			return;
		}
		var acgtBlockSize = 32;
		var buffer = new haxe_io_Bytes(new ArrayBuffer(sequenceChunk.totlen * acgtBlockSize));
		var bufferBlockPos = 0;
		currentOutputBuffer.prepare(buffer.length);
		var unknownMap = new haxe_ds_StringMap();
		var hasUnknownCharacters = false;
		var _g = 0;
		var _g1 = sequenceChunk.totlen;
		while(_g < _g1) {
			var i = _g++;
			var charCode = sequenceChunk.readByte();
			switch(charCode) {
			case 10:
				break;
			case 45:
				var pos = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos,0);
				buffer.setDouble(pos + 8,0);
				buffer.setDouble(pos + 16,0);
				buffer.setDouble(pos + 24,0);
				++bufferBlockPos;
				break;
			case 65:case 97:
				var pos1 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos1,1);
				buffer.setDouble(pos1 + 8,0);
				buffer.setDouble(pos1 + 16,0);
				buffer.setDouble(pos1 + 24,0);
				++bufferBlockPos;
				break;
			case 67:case 99:
				var pos2 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos2,0);
				buffer.setDouble(pos2 + 8,1);
				buffer.setDouble(pos2 + 16,0);
				buffer.setDouble(pos2 + 24,0);
				++bufferBlockPos;
				break;
			case 71:case 103:
				var pos3 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos3,0);
				buffer.setDouble(pos3 + 8,0);
				buffer.setDouble(pos3 + 16,1);
				buffer.setDouble(pos3 + 24,0);
				++bufferBlockPos;
				break;
			case 72:case 104:
				var pos4 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos4,0.33333333333333331);
				buffer.setDouble(pos4 + 8,0.33333333333333331);
				buffer.setDouble(pos4 + 16,0);
				buffer.setDouble(pos4 + 24,0.33333333333333331);
				++bufferBlockPos;
				break;
			case 75:case 107:
				var pos5 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos5,0);
				buffer.setDouble(pos5 + 8,0);
				buffer.setDouble(pos5 + 16,0.5);
				buffer.setDouble(pos5 + 24,0.5);
				++bufferBlockPos;
				break;
			case 78:case 110:
				var pos6 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos6,0.25);
				buffer.setDouble(pos6 + 8,0.25);
				buffer.setDouble(pos6 + 16,0.25);
				buffer.setDouble(pos6 + 24,0.25);
				++bufferBlockPos;
				break;
			case 89:case 121:
				var pos7 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos7,0);
				buffer.setDouble(pos7 + 8,0.5);
				buffer.setDouble(pos7 + 16,0);
				buffer.setDouble(pos7 + 24,0.5);
				++bufferBlockPos;
				break;
			case 66:case 98:
				var pos8 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos8,0);
				buffer.setDouble(pos8 + 8,0.33333333333333331);
				buffer.setDouble(pos8 + 16,0.33333333333333331);
				buffer.setDouble(pos8 + 24,0.33333333333333331);
				++bufferBlockPos;
				break;
			case 68:case 100:
				var pos9 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos9,0.33333333333333331);
				buffer.setDouble(pos9 + 8,0);
				buffer.setDouble(pos9 + 16,0.33333333333333331);
				buffer.setDouble(pos9 + 24,0.33333333333333331);
				++bufferBlockPos;
				break;
			case 77:case 109:
				var pos10 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos10,0.5);
				buffer.setDouble(pos10 + 8,0.5);
				buffer.setDouble(pos10 + 16,0);
				buffer.setDouble(pos10 + 24,0);
				++bufferBlockPos;
				break;
			case 82:case 114:
				var pos11 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos11,0.5);
				buffer.setDouble(pos11 + 8,0);
				buffer.setDouble(pos11 + 16,0.5);
				buffer.setDouble(pos11 + 24,0);
				++bufferBlockPos;
				break;
			case 83:case 115:
				var pos12 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos12,0);
				buffer.setDouble(pos12 + 8,0.5);
				buffer.setDouble(pos12 + 16,0.5);
				buffer.setDouble(pos12 + 24,0);
				++bufferBlockPos;
				break;
			case 84:case 116:
				var pos13 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos13,0);
				buffer.setDouble(pos13 + 8,0);
				buffer.setDouble(pos13 + 16,0);
				buffer.setDouble(pos13 + 24,1);
				++bufferBlockPos;
				break;
			case 85:case 117:
				var pos14 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos14,0);
				buffer.setDouble(pos14 + 8,0);
				buffer.setDouble(pos14 + 16,0);
				buffer.setDouble(pos14 + 24,1);
				++bufferBlockPos;
				break;
			case 86:case 118:
				var pos15 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos15,0.33333333333333331);
				buffer.setDouble(pos15 + 8,0.33333333333333331);
				buffer.setDouble(pos15 + 16,0.33333333333333331);
				buffer.setDouble(pos15 + 24,0);
				++bufferBlockPos;
				break;
			case 87:case 119:
				var pos16 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos16,0.5);
				buffer.setDouble(pos16 + 8,0);
				buffer.setDouble(pos16 + 16,0);
				buffer.setDouble(pos16 + 24,0.5);
				++bufferBlockPos;
				break;
			default:
				hasUnknownCharacters = true;
				var char = String.fromCodePoint(charCode);
				var count = __map_reserved[char] != null ? unknownMap.getReserved(char) : unknownMap.h[char];
				if(count == null) {
					count = 0;
				}
				var value = count + 1;
				if(__map_reserved[char] != null) {
					unknownMap.setReserved(char,value);
				} else {
					unknownMap.h[char] = value;
				}
				var pos17 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos17,0);
				buffer.setDouble(pos17 + 8,0);
				buffer.setDouble(pos17 + 16,0);
				buffer.setDouble(pos17 + 24,0);
				++bufferBlockPos;
			}
		}
		sequenceChunk.close();
		currentOutputBuffer.writeFullBytes(buffer,0,bufferBlockPos * acgtBlockSize);
		if(hasUnknownCharacters) {
			Console.printFormatted(Console.errorPrefix + ("Unknown characters" + " " + unknownMap.toString()) + "\n",2);
		}
	};
	var fastaParser = new FastaParser(onFastaSequenceStart,onFastaSequenceChunk);
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var chunksRequired = Math.ceil(length_bytes / chunkSize_bytes);
	Console.printFormatted(Console.logPrefix + ("" + ("" + chunksRequired + " chunks required")) + "\n",0);
	var tStart = new Date().getTime() / 1000;
	var _g2 = 0;
	var _g11 = chunksRequired;
	while(_g2 < _g11) {
		var chunk = _g2++;
		var t0 = new Date().getTime() / 1000;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(bytesRemaining,chunkSize_bytes) | 0;
		fastaParser.processChunk(input.read(bytesToRead));
		var dt = new Date().getTime() / 1000 - t0;
		var progress = (chunk + 1) / chunksRequired;
		Console.printFormatted(Console.logPrefix + ("" + ("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)")) + "\n",0);
	}
	input.close();
	fastaParser.done();
	var dt1 = new Date().getTime() / 1000 - tStart;
	Console.printFormatted(Console.logPrefix + ("" + ("Converting FASTA file took " + Math.round(dt1 * 10) / 10 + "s (" + Math.round(length_bytes / 1e6 / dt1 * 100) / 100 + " MB/s)")) + "\n",0);
	if(currentOutputBuffer != null) {
		currentOutputBuffer.close();
	}
	return generatedFilePaths;
};
var FastaParser = function(onSequenceStarted,onSequenceChunk) {
	this.headerBuffer = "";
	this.parseMode = 0;
	this.onSequenceStarted = onSequenceStarted;
	this.onSequenceChunk = onSequenceChunk;
};
FastaParser.__name__ = true;
FastaParser.prototype = {
	processChunk: function(bytes) {
		var sequenceStart = 0;
		var _g = 0;
		var _g1 = bytes.length;
		while(_g < _g1) {
			var i = _g++;
			var byte = bytes.b[i];
			switch(this.parseMode) {
			case 1:
				if(byte == 10) {
					this.onSequenceStarted(this.headerBuffer);
					this.parseMode = 2;
					sequenceStart = i + 1;
				} else {
					this.headerBuffer += String.fromCodePoint(byte);
				}
				break;
			case 0:case 2:
				if(byte == 62) {
					if(this.parseMode == 2) {
						var sequenceLength = i - sequenceStart;
						this.onSequenceChunk(new haxe_io_BytesInput(bytes,sequenceStart,sequenceLength));
					}
					this.headerBuffer = "";
					this.parseMode = 1;
				}
				break;
			}
		}
		if(this.parseMode == 2) {
			this.onSequenceChunk(new haxe_io_BytesInput(bytes,sequenceStart));
		}
	}
	,done: function() {
	}
};
Math.__name__ = true;
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,close: function() {
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,prepare: function(nbytes) {
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			var eof1 = (eof instanceof js__$Boot_HaxeError) ? eof.val : eof;
			if((eof1 instanceof haxe_io_Eof)) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	}
	,close: function() {
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
};
var _$UInt_UInt_$Impl_$ = {};
_$UInt_UInt_$Impl_$.__name__ = true;
_$UInt_UInt_$Impl_$.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
};
_$UInt_UInt_$Impl_$.gte = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a >= b;
	}
};
_$UInt_UInt_$Impl_$.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,last: function() {
		if(this.q == null) {
			return null;
		} else {
			return this.q.item;
		}
	}
	,clear: function() {
		this.h = null;
		this.q = null;
		this.length = 0;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,join: function(sep) {
		var s_b = "";
		var first = true;
		var l = this.h;
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += sep == null ? "null" : "" + sep;
			}
			s_b += Std.string(l.item);
			l = l.next;
		}
		return s_b;
	}
	,filter: function(f) {
		var l2 = new haxe_ds_List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			if(f(v)) {
				l2.add(v);
			}
		}
		return l2;
	}
	,map: function(f) {
		var b = new haxe_ds_List();
		var l = this.h;
		while(l != null) {
			var v = l.item;
			l = l.next;
			b.add(f(v));
		}
		return b;
	}
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,toString: function() {
		var s_b = "";
		s_b += "{";
		var keys = this.arrayKeys();
		var _g = 0;
		var _g1 = keys.length;
		while(_g < _g1) {
			var i = _g++;
			var k = keys[i];
			s_b += k == null ? "null" : "" + k;
			s_b += " => ";
			s_b += Std.string(Std.string(__map_reserved[k] != null ? this.getReserved(k) : this.h[k]));
			if(i < keys.length - 1) {
				s_b += ", ";
			}
		}
		s_b += "}";
		return s_b;
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,setDouble: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g = 1;
	var _g1 = paths1.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2 = 0;
	var _g3 = tmp.length;
	while(_g2 < _g3) {
		var i = _g2++;
		var _g21 = tmp.charCodeAt(i);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i1 = _g21;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i1);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i2 = _g21;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i2);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		var _1 = (_ instanceof js__$Boot_HaxeError) ? _.val : _;
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
		if(e1.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				var _1 = (_ instanceof js__$Boot_HaxeError) ? _.val : _;
				throw e1;
			}
			if(!stat.isDirectory()) {
				throw e1;
			}
		}
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileOutput.__name__ = true;
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(b) {
		var buf = new js_node_buffer_Buffer(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b><gray>><//> ";
Console.warnPrefix = "<b><yellow>><//> ";
Console.errorPrefix = "<b><red>><//> ";
Console.successPrefix = "<b><light_green>><//> ";
Console.unicodeCompatibilityMode = Sys.systemName() == "Windows" ? 1 : 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
Main.main();
})();
